
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/clustering.ipynb

import pickle
import numpy as np
import os
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
from sklearn.metrics import silhouette_score, pairwise_distances_argmin_min

def load_features(path):
    _, _, fnames = next(os.walk(path))

    features = []
    for fname in fnames:
        with open(os.path.join(path, fname), 'rb') as f:
            feature_dict = pickle.load(f)
            features.append(feature_dict)

    return features

def k_means(feature_vectors, k_range=[2, 3]):
    # finding best k
    bst_k          = k_range[0]
    bst_silhouette = -1
    bst_labels     = None
    bst_centroids  = None
    bst_kmeans     = None
    for k in k_range:
        kmeans = KMeans(n_clusters = k)
        kmeans.fit(feature_vectors)

        labels    = kmeans.predict(feature_vectors)
        centroids = kmeans.cluster_centers_

        silhouette_avg = silhouette_score(feature_vectors, labels)
        if silhouette_avg > bst_silhouette:
            bst_k          = k
            bst_silhouette = silhouette_avg
            bst_labels     = labels
            bst_centroids  = centroids
            bst_kmeans     = kmeans

    print("Best K was", bst_k, "with a silhouette score of", bst_silhouette)

    centroid_mthds = pairwise_distances_argmin_min(bst_centroids, feature_vectors)
    return bst_labels, bst_centroids, bst_kmeans, centroid_mthds

# Uses PCA first and then t-SNE
def reduce_dims(feature_vectors, dims = 2):
    # hyperparameters from https://towardsdatascience.com/visualising-high-dimensional-datasets-using-pca-and-t-sne-in-python-8ef87e7915b
    pca = PCA(n_components=50)
    pca_features = pca.fit_transform(feature_vectors)

    tsne = TSNE(n_components=dims, verbose=1, perplexity=40, n_iter=300)
    tsne_features = tsne.fit_transform(pca_features)

    return tsne_features

def cluster(models_features, k_range = [2], dims = 2):
    clusters = []
    for model in models_features:
        feature_vectors = reduce_dims(np.array(list(model.values())), dims = dims)

        experimental_vectors = feature_vectors[:len(experimental_vectors) * 0.1]
        labels, centroids, kmeans, centroid_mthds = k_means(experimental_vectors, k_range = k_range)
        clusters.append((feature_vectors, centroid_mthds, labels, centroids, kmeans))

    return clusters